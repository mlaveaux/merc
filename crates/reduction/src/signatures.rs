use std::fmt::Debug;
use std::hash::Hash;

use mcrl3_lts::LabelIndex;
use mcrl3_lts::LabelledTransitionSystem;
use mcrl3_lts::StateIndex;
use rustc_hash::FxHashSet;

use crate::BlockIndex;
use crate::Partition;
use crate::quotient_lts_naive;

use super::BlockPartition;
use super::IndexedPartition;
use super::reorder_partition;
use super::sort_topological;
use super::tau_scc_decomposition;

/// The builder used to construct the signature.
pub type SignatureBuilder = Vec<(LabelIndex, BlockIndex)>;

/// The type of a signature. We use sorted vectors to avoid the overhead of hash
/// sets that might have unused values.
#[derive(Eq)]
pub struct Signature(*const [(LabelIndex, BlockIndex)]);

impl Signature {
    pub fn new(slice: &[(LabelIndex, BlockIndex)]) -> Signature {
        Signature(slice)
    }

    pub fn as_slice(&self) -> &[(LabelIndex, BlockIndex)] {
        unsafe { &*self.0 }
    }
}

impl Signature {
    // Check if target is a subset of self, excluding a specific element
    pub fn is_subset_of(&self, other: &[(LabelIndex, BlockIndex)], exclude: (LabelIndex, BlockIndex)) -> bool {
        let mut self_iter = self.as_slice().iter();
        let mut other_iter = other.iter().filter(|&&x| x != exclude);

        let mut self_item = self_iter.next();
        let mut other_item = other_iter.next();

        while let Some(&o) = other_item {
            match self_item {
                Some(&s) if s == o => {
                    // Match found, move both iterators forward
                    self_item = self_iter.next();
                    other_item = other_iter.next();
                }
                Some(&s) if s < o => {
                    // Move only self iterator forward
                    self_item = self_iter.next();
                }
                _ => {
                    // No match found in self for o
                    return false;
                }
            }
        }
        // If we finished self_iter without returning false, self is a subset
        true
    }
}

// This default implementation is actually different from the one generated by derive(Default).
#[allow(clippy::derivable_impls)]
impl Default for Signature {
    fn default() -> Self {
        Signature(&[])
    }
}

impl PartialEq for Signature {
    fn eq(&self, other: &Self) -> bool {
        self.as_slice() == other.as_slice()
    }
}

impl Hash for Signature {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        unsafe { (*self.0).hash(state) }
    }
}

impl Debug for Signature {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_list().entries(self.as_slice().iter()).finish()
    }
}

/// Returns true if the label is the special tau_hat label for the given LTS.
pub fn is_tau_hat(label: LabelIndex, lts: &LabelledTransitionSystem) -> bool {
    label == lts.num_of_labels()
}

/// Returns a special label that is not in the set of labels.
fn tau_hat(lts: &LabelledTransitionSystem) -> LabelIndex {
    LabelIndex::new(lts.num_of_labels())
}

/// Returns the signature for strong bisimulation sig(s, pi) = { (a, pi(t)) | s -a-> t in T }
pub fn strong_bisim_signature(
    state_index: StateIndex,
    lts: &LabelledTransitionSystem,
    partition: &impl Partition,
    builder: &mut SignatureBuilder,
) {
    builder.clear();

    for transition in lts.outgoing_transitions(state_index) {
        builder.push((transition.label, partition.block_number(transition.to)));
    }

    // Compute the flat signature, which has Hash and is more compact.
    builder.sort_unstable();
    builder.dedup();
}

/// Returns the branching bisimulation signature for branching bisimulation
/// sig(s, pi) = { (a, pi(t)) | s -[tau]-> s1 -> ... s_n -[a]-> t in T && pi(s) = pi(s_i) && ((a != tau) || pi(s) != pi(t)) }
pub fn branching_bisim_signature(
    state_index: StateIndex,
    lts: &LabelledTransitionSystem,
    partition: &impl Partition,
    builder: &mut SignatureBuilder,
    visited: &mut FxHashSet<StateIndex>,
    stack: &mut Vec<StateIndex>,
) {
    // Clear the builders and the list of visited states.
    builder.clear();
    visited.clear();

    // A stack used for depth first search of tau paths.
    debug_assert!(stack.is_empty(), "The stack should be empty");
    stack.push(state_index);

    while let Some(inner_state_index) = stack.pop() {
        visited.insert(inner_state_index);

        for transition in lts.outgoing_transitions(inner_state_index) {
            if lts.is_hidden_label(transition.label) {
                if partition.block_number(state_index) == partition.block_number(transition.to) {
                    // Explore the outgoing state as well, still tau path in same block
                    if !visited.contains(&transition.to) {
                        visited.insert(transition.to);
                        stack.push(transition.to);
                    }
                } else {
                    //  pi(s) != pi(t)
                    builder.push((transition.label, partition.block_number(transition.to)));
                }
            } else {
                // (a != tau) This is a visible action only reachable from tau paths with equal signatures.
                builder.push((transition.label, partition.block_number(transition.to)));
            }
        }
    }

    // Compute the flat signature, which has Hash and is more compact.
    builder.sort_unstable();
    builder.dedup();
}

/// The input lts must contain no tau-cycles.
pub fn branching_bisim_signature_sorted(
    state_index: StateIndex,
    lts: &LabelledTransitionSystem,
    partition: &impl Partition,
    state_to_signature: &[Signature],
    builder: &mut SignatureBuilder,
) {
    builder.clear();

    for transition in lts.outgoing_transitions(state_index) {
        let to_block = partition.block_number(transition.to);

        if partition.block_number(state_index) == to_block {
            if lts.is_hidden_label(transition.label) {
                // Inert tau transition, take signature from the outgoing tau-transition.
                builder.extend(state_to_signature[transition.to].as_slice());
            } else {
                builder.push((transition.label, to_block));
            }
        } else {
            // Visible action, add to the signature.
            builder.push((transition.label, to_block));
        }
    }

    // Compute the flat signature, which has Hash and is more compact.
    builder.sort_unstable();
    builder.dedup();
}

/// The input lts must contain no tau-cycles.
pub fn branching_bisim_signature_inductive(
    state_index: StateIndex,
    lts: &LabelledTransitionSystem,
    partition: &BlockPartition,
    state_to_key: &[BlockIndex],
    builder: &mut SignatureBuilder,
) {
    builder.clear();

    for transition in lts.outgoing_transitions(state_index) {
        let to_block = partition.block_number(transition.to);

        if partition.block_number(state_index) == to_block {
            if lts.is_hidden_label(transition.label) && partition.is_element_marked(transition.to) {
                // Inert tau transition, take signature from the outgoing tau-transition.
                builder.push((tau_hat(lts), state_to_key[transition.to]));
            } else {
                builder.push((transition.label, to_block));
            }
        } else {
            // Visible action, add to the signature.
            builder.push((transition.label, to_block));
        }
    }

    // Compute the flat signature, which has Hash and is more compact.
    builder.sort_unstable();
    builder.dedup();
}

/// Perform the preprocessing necessary for branching bisimulation with the
/// sorted signature see `branching_bisim_signature_sorted`.
pub fn preprocess_branching(lts: LabelledTransitionSystem) -> (LabelledTransitionSystem, IndexedPartition) {
    let scc_partition = tau_scc_decomposition(&lts);
    let tau_loop_free_lts = quotient_lts_naive(&lts, &scc_partition, true);
    drop(lts);

    // Sort the states according to the topological order of the tau transitions.
    let topological_permutation = sort_topological(
        &tau_loop_free_lts,
        |label_index, _| tau_loop_free_lts.is_hidden_label(label_index),
        true,
    )
    .expect("After quotienting, the LTS should not contain cycles");

    (
        LabelledTransitionSystem::new_from_permutation(tau_loop_free_lts, |i| topological_permutation[i]),
        reorder_partition(scc_partition, |i| BlockIndex::new(topological_permutation[i].value())),
    )
}
